;;; Generated by Verrazano 0.5
(in-package portaudio)

(define-foreign-library libportaudio
 (:darwin "libportaudio.dylib") ;; <--- added
 ((:and :unix (:not :darwin)) (:or "libportaudio.so.2" "libportaudio.so"))
 ((:or :win32 :x86-64) (:or "libportaudio" "libportaudio-2"
"portaudio" "portaudio_x64" "portaudio_x86_64"))
 ((:or :win32 :x86) (:or "libportaudio" "libportaudio-2" "portaudio"
"portaudio_x86"))
 (t (:default "libportaudio")))

(use-foreign-library libportaudio)

(defcfun ("Pa_GetErrorText" %get-error-text) :string (error-code :int))


;; Generated by me, based on "Joost Diepenmaat <joost@zeekat.nl>" version
(defmacro make-errors (&rest symbols)
  `(eval-when (:compile-toplevel :load-toplevel :execute)
     (defcenum pa-error ,@symbols)
     ,@(mapcar #'(lambda (sym)
                   `(define-condition ,(if (listp sym)
                                           (car sym)
                                           sym) (error)
                      ((value :initform ,(if (listp sym)
                                             (car sym)
                                             sym)))
                      (:documentation "pa-error condition")
                      (:report (lambda (condition stream)
                                 (format stream "~A."
                                         (%get-error-text (foreign-enum-value 'pa-error (slot-value condition 'value))))))))
               symbols)))

(make-errors	
 (:no-error 0)
 (:not-anticipated -10000)
 :unanticipated-host-error
 :invalid-channel-count
 :invalid-sample-rate
 :invalid-device
 :invalid-flag
 :sample-format-not-supported
 :bad-i-o-device-combination
 :insufficient-memory
 :buffer-too-big
 :buffer-too-small
 :null-callback
 :bad-stream-ptr
 :timed-out
 :internal-error
 :device-unavailable
 :incompatible-host-api-specific-stream-info
 :stream-is-stopped
 :stream-is-not-stopped
 :input-overflowed
 :output-underflowed
 :host-api-not-found
 :invalid-host-api
 :can-not-read-from-a-callback-stream
 :can-not-write-to-a-callback-stream
 :can-not-read-from-an-output-only-stream
 :can-not-write-to-an-input-only-stream
 :incompatible-stream-host-api
 :bad-buffer-ptr)

(defun raise-if-error (err)
  "Check err and raise condition if it is needed"
  (cond
    ((numberp err)
     (if (<= -10000 err -9972)
         (error (foreign-enum-keyword 'pa-error err))
         err))
    (t
     (if (not (eql err :no-error))
         (error err)))))

(defbitfield (sample-format :unsigned-long)
  (:float #x0001) ; cffi::float
;;  :int32            ; cffi::int32 
;;  :int24            ; not supported
;;  :int16            ; cffi::int16 troubles
;;  :int8             ; cffi::int8 
;;  :uint8            ; cffi::uint8 
;;  (:custom-format #x00010000) ; not supported 
;;  (:non-interleaved #x80000000)
  )

(defun cffi-type-to-lisp (cffi-type)
  (case cffi-type
    (:float 'single-float)
    (:int32 '(signed-byte 32))
    (:int16 '(signed-byte 16))
    (:int8  '(signed-byte 8))
    (:uint8 '(unsigned-byte 8))))

;;(defconstant +non-interleaved+ #x80000000)

(defbitfield (stream-flags :unsigned-long)
  (:no-flag #x00000000)
  (:clip-off #x00000001)
  (:dither-off #x00000002)
;;  (:never-drop-input #x00000004)
;;  (:prime-output-buffers-using-stream-callback #x00000008)
;;  (:platform-specific-flags #xFFFF0000)
)

(defconstant +format-is-supported+ 0)
(defconstant +frames-per-buffer-unspecified+ 0)

(defconstant +no-device+ -1)
(defconstant +use-host-api-specific-device-specification -2)

(defctype pa-stream-t :void)

(defctype host-api-index :int)

(defcenum host-api-type-id
  (:in-development 0)
  (:direct-sound 1)
  (:mme 2)
  (:asio 3)
  (:sound-manager 4)
  (:core-audio 5)
  (:oss 7)
  (:alsa 8)
  (:al 9)
  (:be-os 10)
  (:wdmks 11)
  (:jack 12)
  (:wasapi 13)
  (:audio-science-hpi 14))

(defclass pa-stream ()
  ((handle :initform (null-pointer)
           :accessor pa-stream-handle
           :initarg :handle :documentation "Foreign pointer to pa-stream")
   (input-sample-format :initarg :input-sample-format :reader pa-stream-input-sample-format :documentation "Format of input samples")
   (input-channels :initarg :input-channels :reader pa-stream-input-channels :documentation "Number of input channels")
   (output-sample-format :initarg :output-sample-format :reader pa-stream-output-sample-format :documentation "Format of output samples")
   (output-channels :initarg :output-channels :reader pa-stream-output-channels :documentation "Number of output channels")
   (frames-per-buffer :initarg :frames-per-buffer :reader pa-stream-frames-per-buffer :documentation "Frames per buffer"))
  (:documentation "A single PaStream can provide multiple channels of real-time streaming audio input and output to a client application. A stream provides access to audio hardware represented by one or more devices. Depending on the underlying Host API, it may be possible to open multiple streams using the same device, however this behavior is implementation defined. Portable applications should assume that a device may be simultaneously used by at most one stream."))
(export 'pa-stream)
(export 'pa-stream-input-sample-format)
(export 'pa-stream-input-channels)
(export 'pa-stream-output-sample-format)
(export 'pa-stream-output-channels)
(export 'pa-stream-frames-per-buffer)

(defgeneric pa-stream-input-sample-format (instance)
  (:documentation "value of sample-format for input channel"))
(defgeneric pa-stream-input-channels (instance)
  (:documentation "Number of input channels"))
(defgeneric pa-stream-output-sample-format (instance)
  (:documentation "value of sample-format for output channel"))
(defgeneric pa-stream-output-channels (instance)
  (:documentation "Number of output channels"))
(defgeneric pa-stream-frames-per-buffer (instance)
  (:documentation "Frames per buffer for current stream"))

(defctype p-pa-stream :pointer "Pointer to pa-stream")
(define-foreign-type p-pa-stream ()
  ()
  (:actual-type :pointer)
  (:simple-parser p-pa-stream))

(defmethod translate-to-foreign (value (type p-pa-stream))
  (pa-stream-handle value))

(defctype device-index :int)

(defctype pa-time :double)

(defcstruct host-error-info
  (host-api-type host-api-type-id)
  (error-code :long)
  (error-text :string))

(defclass host-error-info nil
  ((host-api-type :reader host-error-info-host-api-type :documentation "the host API which returned the error code")
   (error-code :reader host-error-info-error-code :documentation "the error code returned")
   (error-text :reader host-error-info-error-text :documentation "a textual description of the error if available, otherwise a zero-length string"))
  (:documentation "Structure used to return information about a host error condition."))
(defmethod initialize-instance :after
    ((inst host-error-info) &key pointer)
  (with-foreign-slots ((host-api-type error-code error-text) pointer
                       host-error-info)
    (setf (slot-value inst 'host-api-type) host-api-type)
    (setf (slot-value inst 'error-code) error-code)
    (setf (slot-value inst 'error-text) error-text)))
(export 'host-error-info)
(export 'host-error-info-host-api-type)
(export 'host-error-info-error-code)
(export 'host-error-info-error-text)

(defgeneric host-error-info-host-api-type (instance)(:documentation "the host API which returned the error code"))
(defgeneric host-error-info-error-code (instance)(:documentation "the error code returned"))
(defgeneric host-error-info-error-text (instance)(:documentation "a textual description of the error if available, otherwise a zero-length string"))

(defctype p-host-error-info :pointer "Pointer to p-host-error-info")
(define-foreign-type p-host-error-info ()
  ()
  (:actual-type :pointer)
  (:simple-parser p-host-error-info))

(defmethod translate-from-foreign (value (type p-host-error-info))
  (unless (null-pointer-p value)
    (make-instance 'host-error-info :pointer value)))

(defcfun ("Pa_GetLastHostErrorInfo" %get-last-host-error-info) p-host-error-info)
(defun get-last-host-error-info ()
  "Return information about the last host error encountered. The error information returned by @fun{get-last-host-error-info} will never be modified asynchronously by errors occurring in other PortAudio owned threads.

This function is provided as a last resort, primarily to enhance debugging by providing clients with access to all available error information.

@begin{return}
A structure constraining information about the host error. The values in this structure will only be valid if a PortAudio function has previously raise the unanticipated-host-error error code. 
@end{return}
"
  (%get-last-host-error-info))
  
(defcfun ("Pa_GetVersion" %get-version) :int)
(defun get-version ()
  "Retrieve the release number of the currently running PortAudio build, eg 1900."
  (%get-version))
(export 'get-version)

(defcfun ("Pa_GetVersionText" %get-version-text) :string)
(defun get-version-text ()
  "Retrieve a textual description of the current PortAudio build,
eg \"PortAudio V19-devel 13 October 2002\"."
  (%get-version-text))
(export 'get-version-text)


(defcfun ("Pa_GetDeviceCount" %get-device-count) device-index)
(defun get-device-count ()
  "Retrieve the number of available devices.The number of available devices may be zero.
@begin{return}
A non-negative value indicating the number of available devices or, raises an error if PortAudio is not initialized or an error is encountered. 
@end{return}"
  (raise-if-error (%get-device-count)))
(export 'get-device-count)

(defcfun ("Pa_GetDefaultOutputDevice" %get-default-output-device) device-index)
(defun get-default-output-device ()
  "Retrieve the index of the default output device. The result can be used in the outputDevice parameter to @fun{open-stream}.

@b{Note}

On the PC, the user can specify a default device by setting an environment variable. For example, to use device #1.

@pre{set PA_RECOMMENDED_OUTPUT_DEVICE=1}

The user should first determine the available device ids by using @code{(@fun{print-devices})}. 

@begin{return}
The default output device index for the default host API, or raise no-device if no default output device is available or an error was encountered.
@end{return}
"
  (raise-if-error (%get-default-output-device)))
(export 'get-default-output-device)

(defcstruct device-info
  (struct-version :int)
  (name :string)
  (host-api host-api-index)
  (max-input-channels :int)
  (max-output-channels :int)
  (default-low-input-latency pa-time)
  (default-low-output-latency pa-time)
  (default-high-input-latency pa-time)
  (default-high-output-latency pa-time)
  (default-sample-rate :double))

(defclass device-info nil
  ((struct-version :reader device-info-struct-version
                   :documentation "Structure version.")
   (name :reader device-info-name :documentation "Device name.")
   (host-api :reader device-info-host-api :documentation "note this is a host API index, not a type id.")
   (max-input-channels :reader device-info-max-input-channels :documentation "")
   (max-output-channels :reader device-info-max-output-channels)
   (default-low-input-latency :reader
                              device-info-default-low-input-latency
                              :documentation "Default latency values for interactive performance.")
   (default-low-output-latency :reader
                               device-info-default-low-output-latency
                               :documentation "")
   (default-high-input-latency :reader device-info-default-high-input-latency
                               :documentation "Default latency values for robust non-interactive applications (eg. playing sound files).")p
   (default-high-output-latency :reader
                                device-info-default-high-output-latency
                                :documentation "")
   (default-sample-rate :reader device-info-default-sample-rate :documentation "Sample rate"))
  (:documentation "A structure providing information and capabilities of PortAudio devices. Devices may support input, output or both input and output."))
(defmethod initialize-instance :after
    ((inst device-info) &key pointer)
  (with-foreign-slots ((struct-version name host-api max-input-channels
                                       max-output-channels default-low-input-latency
                                       default-low-output-latency default-high-input-latency
                                       default-high-output-latency default-sample-rate)
                       pointer device-info)
     (setf (slot-value inst 'struct-version) struct-version)
     (setf (slot-value inst 'name) name)
     (setf (slot-value inst 'host-api) host-api)
     (setf (slot-value inst 'max-input-channels) max-input-channels)
     (setf (slot-value inst 'max-output-channels) max-output-channels)
     (setf (slot-value inst 'default-low-input-latency)
             default-low-input-latency)
     (setf (slot-value inst 'default-low-output-latency)
             default-low-output-latency)
     (setf (slot-value inst 'default-high-input-latency)
             default-high-input-latency)
     (setf (slot-value inst 'default-high-output-latency)
             default-high-output-latency)
     (setf (slot-value inst 'default-sample-rate) default-sample-rate)))

(export 'device-info)
(export 'device-info-name)
(export 'device-info-host-api)
(export 'device-info-max-input-channels)
(export 'device-info-max-output-channels)
(export 'device-info-default-low-input-latency)
(export 'device-info-default-high-input-latency)
(export 'device-info-default-low-output-latency)
(export 'device-info-default-high-output-latency)
(export 'device-info-default-sample-rate)

(defgeneric device-info-name  (instance) (:documentation "device name")) 
(defgeneric device-info-host-api (instance) (:documentation "note this is a host API index, not a type id.")) 
(defgeneric device-info-max-input-channels (instance) (:documentation "maximum number of input channels")) 
(defgeneric device-info-max-output-channels  (instance) (:documentation "maximum number of output channels")) 
(defgeneric device-info-default-low-input-latency (instance) (:documentation "Default latency values for interactive performance.")) 
(defgeneric device-info-default-high-input-latency (instance) (:documentation "Default latency values for robust non-interactive applications (eg. playing sound files).")) 
(defgeneric device-info-default-low-output-latency (instance) (:documentation "")) 
(defgeneric device-info-default-high-output-latency (instance) (:documentation ""))
(defgeneric device-info-default-sample-rate  (instance) (:documentation "Sample rate"))


(defctype p-device-info :pointer "Pointer to device-info")
(define-foreign-type p-device-info ()
  ()
  (:actual-type :pointer)
  (:simple-parser p-device-info))

 ;;; Define a method that converts C to Lisp.
(defmethod translate-from-foreign (value (type p-device-info))
  (unless (null-pointer-p value)
    (make-instance 'device-info :pointer value)))

(defcfun ("Pa_GetDeviceInfo" %get-device-info) p-device-info
  (device device-index))
(defun get-device-info (device)
  "Retrieve @class{device-info} structure containing information about the specified device.

@begin{return}
A object of @class{device-info}. If the device parameter is out of range the function returns NIL.
@end{return}

@arg[device]{A valid device index in the range 0 to @code{(- (@fun{get-device-count}) 1)}}
"
  (%get-device-info device))
(export 'get-device-info)

(defcstruct stream-parameters
  (device device-index)
  (channel-count :int)
  (sample-format sample-format)
  (suggested-latency pa-time)
  (host-api-specific-stream-info (:pointer :void)))

(defclass stream-parameters ()
  ((device :accessor stream-parameters-device
           :documentation "A valid device index in the range 0 to (- get-device-count 1) specifying the device to be used. This field must not be set to paNoDevice.")
   (channel-count :accessor stream-parameters-channel-count
                  :documentation "The number of channels of sound to be delivered to the stream callback.")
   (sample-format :accessor stream-parameters-sample-format
                  :documentation "The sample format of the buffer provided to read-stream or write-stream.")
   (suggested-latency :accessor stream-parameters-suggested-latency
                      :documentation "The desired latency in seconds. Where practical, implementations should configure their latency based on these parameters, otherwise they may choose the closest viable latency instead. Unless the suggested latency is greater than the absolute upper limit for the device implementations should round the suggestedLatency up to the next practical value - ie to provide an equal or higher latency than suggestedLatency wherever possible."))
  (:documentation "Parameters for one direction (input or output) of a stream."))
(export 'stream-parameters)
(export 'stream-parameters-device)
(export 'stream-parameters-channel-count)
(export 'stream-parameters-sample-format)
(export 'stream-parameters-suggested-latency)

(defgeneric stream-parameters-device             (instance) (:documentation "A valid device index in the range 0 to @code{(- (@fun{get-device-count}) 1)} specifying the device to be used. This field must not be set to paNoDevice.")) 
(defgeneric stream-parameters-channel-count      (instance) (:documentation "The number of channels of sound to be delivered to the stream callback.")) 
(defgeneric stream-parameters-sample-format      (instance) (:documentation "The sample format of the buffer provided to read-stream or write-stream.")) 
(defgeneric stream-parameters-suggested-latency  (instance) (:documentation "The desired latency in seconds. Where practical, implementations should configure their latency based on these parameters, otherwise they may choose the closest viable latency instead. Unless the suggested latency is greater than the absolute upper limit for the device implementations should round the suggestedLatency up to the next practical value - ie to provide an equal or higher latency than suggestedLatency wherever possible.")) 

(defun make-stream-parameters ()
  "Make stream-parameters object"
  (make-instance 'stream-parameters))
(export 'make-stream-parameters)

(defctype p-stream-parameters :pointer "Pointer to stream parameters")
(define-foreign-type p-stream-parameters ()
  ()
  (:actual-type :pointer)
  (:simple-parser p-stream-parameters))

(defmethod translate-from-foreign (value (type p-stream-parameters))
  (unless (null-pointer-p value)
    (let ((stream-parameters (make-instance 'stream-parameters)))
      (setf (slot-value stream-parameters 'device) (foreign-slot-value value 'stream-parameters 'device)
            (slot-value stream-parameters 'channel-count) (foreign-slot-value value 'stream-parameters 'channel-count)
            (slot-value stream-parameters 'sample-format) (car
                                                           (foreign-bitfield-symbols
                                                            'sample-format
                                                            (foreign-slot-value value 'stream-parameters 'sample-format)))
            (slot-value stream-parameters 'suggested-latency) (foreign-slot-value value 'stream-parameters 'suggested-latency))
      stream-parameters)))

(defmethod translate-to-foreign (value (type p-stream-parameters))
  (if value
      (let ((parameters (foreign-alloc 'stream-parameters)))
        (setf (foreign-slot-value parameters 'stream-parameters 'device) (slot-value value 'device)
              (foreign-slot-value parameters 'stream-parameters 'channel-count) (slot-value value 'channel-count)
              (foreign-slot-value parameters 'stream-parameters 'sample-format) (foreign-bitfield-value
                                                                                 'sample-format
                                                                                 (list (slot-value value 'sample-format)))
              (foreign-slot-value parameters 'stream-parameters 'suggested-latency) (slot-value value 'suggested-latency)
              (foreign-slot-value parameters 'stream-parameters 'host-api-specific-stream-info) (null-pointer))
        parameters)
      (null-pointer)))

(defmethod free-translated-object (value (type p-stream-parameters) param)
  (declare (ignore param))
  (unless (null-pointer-p value)
    (foreign-free value)))

(defcfun ("Pa_IsFormatSupported" %is-format-supported) pa-error
  (input-parameters p-stream-parameters)
  (output-parameters p-stream-parameters)
  (sample-rate :double))
(defun is-format-supported (input-parameters output-parameters sample-rate)
  "Determine whether it would be possible to open a stream with the specified parameters.

@arg[input-parameters]{A structure that describes the input parameters used to open a stream. The suggested-latency slot is ignored. See @class{stream-parameters} for a description of these parameters. input-parameters must be NIL for output-only streams.}
@arg[output-parameters]{A structure that describes the output parameters used to open a stream. The suggested-latency field is ignored. See @class{stream-parameters} for a description of these parameters. output-parameters must be NIL for input-only streams.}
@arg[sample-rate]{The required sampleRate. For full-duplex streams it is the sample rate for both input and output.}

@begin{return}
Returns 0 if the format is supported, and raises an error indicating why the format is not supported otherwise. The constant @variable{+format-is-supported+} is provided to compare with the return value for success.
@end{return}
"
  (raise-if-error (%is-format-supported input-parameters output-parameters sample-rate)))

(defcfun ("Pa_HostApiTypeIdToHostApiIndex" %host-api-type-id-to-host-api-index) host-api-index
  (type host-api-type-id))
(defun host-api-type-id-to-host-api-index (type)
  "Convert a static host API unique identifier, into a runtime host API index.
@arg[type]{A unique host API identifier belonging to the PaHostApiTypeId enumeration.}

@begin{return}
A valid host-api-idnex ranging from 0 to @code{(- (@fun{get-host-api-count}) 1)} or, raises an error if PortAudio is not initialized or
@end{return}

The host-api-not-found error indicates that the host API specified by the type parameter is not available.

"
  (raise-if-error (%host-api-type-id-to-host-api-index type)))
(export 'host-api-type-id-to-host-api-index)

(defcfun ("Pa_GetDefaultInputDevice" %get-default-input-device) device-index)
(defun get-default-input-device ()
  "Retrieve the index of the default input device. The result can be used in the inputDevice parameter to @fun{open-stream}.
@begin{return}
The default input device index for the default host API, or raise no-device if no default input device is available or an error was encountered. 
@end{return}"
  (raise-if-error (%get-default-input-device)))
(export 'get-default-input-device)

(defcstruct host-api-info
  (struct-version :int)
  (type host-api-type-id)
  (name :string)
  (device-count :int)
  (default-input-device device-index)
  (default-output-device device-index))
(defclass host-api-info nil
  ((struct-version :reader host-api-info-struct-version :documentation "Struct version.")
   (type :reader host-api-info-type :documentation "The well known unique identifier of this host API.")
   (name :reader host-api-info-name :documentation "A textual description of the host API for display on user interfaces.")
   (device-count :reader host-api-info-device-count :documentation "The number of devices belonging to this host API. This field may be used in conjunction with host-api-device-index-to-device-index to enumerate all devices for this host API." )
   (default-input-device :reader host-api-info-default-input-device
                         :documentation "The default input device for this host API. The value will be a device index ranging from 0 to (- (get-device-count) 1), or no-device if no default input device is available.")
   (default-output-device :reader
                          host-api-info-default-output-device
                          :documentation "The default output device for this host API. The value will be a device index ranging from 0 to (- (get-device-count) 1), or paNoDevice if no default output device is available."))
  (:documentation "A structure containing information about a particular host API."))

(defmethod initialize-instance :after
    ((inst host-api-info) &key pointer)
  (with-foreign-slots ((struct-version type name device-count
                                       default-input-device default-output-device)
                       pointer host-api-info)
    (setf (slot-value inst 'struct-version) struct-version)
    (setf (slot-value inst 'type) type)
    (setf (slot-value inst 'name) name)
    (setf (slot-value inst 'device-count) device-count)
    (setf (slot-value inst 'default-input-device) default-input-device)
    (setf (slot-value inst 'default-output-device)
          default-output-device)))

(export 'host-api-info)
(export 'host-api-info-type)
(export 'host-api-info-name)
(export 'host-api-info-device-count)
(export 'host-api-info-default-input-device)
(export 'host-api-info-default-output-device)

(defgeneric host-api-info-type                   (instance) (:documentation "The well known unique identifier of this host API.")) 
(defgeneric host-api-info-name                   (instance) (:documentation "A textual description of the host API for display on user interfaces.")) 
(defgeneric host-api-info-device-count           (instance) (:documentation "The number of devices belonging to this host API. This field may be used in conjunction with host-api-device-index-to-device-index to enumerate all devices for this host API.")) 
(defgeneric host-api-info-default-input-device   (instance) (:documentation "The default input device for this host API. The value will be a device index ranging from 0 to (- (get-device-count) 1), or no-device if no default input device is available.")) 
(defgeneric host-api-info-default-output-device  (instance) (:documentation "The default output device for this host API. The value will be a device index ranging from 0 to (- (get-device-count) 1), or paNoDevice if no default output device is available.")) 

(defctype p-host-api-info :pointer)
(define-foreign-type p-host-api-info ()
  ()
  (:actual-type :pointer)
  (:simple-parser p-host-api-info))
(defmethod translate-from-foreign (value (type p-host-api-info))
  (unless (null-pointer-p value)
    (make-instance 'host-api-info :pointer value)))

(defcfun ("Pa_GetHostApiInfo" %get-host-api-info) p-host-api-info
  (host-api host-api-index))
(defun get-host-api-info (host-api)
  "Retrieve a pointer to a structure containing information about a specific host Api.

@begin[host-api]{arg}
A valid host API index ranging from 0 to @code{(- (@fun{get-host-api-count}) 1)}
@end{arg}

@begin{return}
An object of @class{host-api-info} describing a specific host API. If the hostApi parameter is out of range or an error is encountered, the function returns NIL.
@end{return}
"
  (%get-host-api-info host-api))
(export 'get-host-api-info)

(defcfun ("Pa_Initialize" %initialize) pa-error)
(defun initialize ()
  "Library initialization function - call this before using PortAudio. This function initializes internal data structures and prepares underlying host APIs for use. With the exception of @fun{get-version}, @fun{get-version-text}, and @fun{get-error-text}, this function MUST be called before using any other PortAudio API functions.

If initialize is called multiple times, each successful call must be matched with a corresponding call to @fun{terminate}. Pairs of calls to initialize/@fun{terminate} may overlap, and are not required to be fully nested.

Note that if initialize raises an error, @fun{terminate} should NOT be called.

@result{NIL if successful, otherwise raises an error indicating the cause of failure.}
"
  (raise-if-error (%initialize)))
(export 'initialize)

(defcfun ("Pa_Terminate" %terminate) pa-error)
(defun terminate ()
"
Library termination function - call this when finished using PortAudio. This function deallocates all resources allocated by PortAudio since it was initialized by a call to @fun{initialize}. In cases where @fun{initialize} has been called multiple times, each call must be matched with a corresponding call to terminate. The final matching call to terminate will automatically close any PortAudio streams that are still open.

terminate MUST be called before exiting a program which uses PortAudio. Failure to do so may result in serious resource leaks, such as audio devices not being available until the next reboot.

@begin{return}
NIL if successful, otherwise raises an error indicating the cause of failure.
@end{return}
"
  (raise-if-error (%terminate)))
(export 'terminate)

(defcfun ("Pa_GetDefaultHostApi" %get-default-host-api) host-api-index)
(defun get-default-host-api ()
  "Retrieve the index of the default host API. The default host API will be the lowest common denominator host API on
 the current platform and is unlikely to provide the best performance.

@begin{return}
A non-negative value ranging from 0 to @code{(- (@fun{get-host-api-count}) 1)} indicating the default host API index or, raises an error if PortAudio is not initialized or an error is encountered. 
@end{return}
"
  (raise-if-error (%get-default-host-api)))
(export 'get-default-host-api)



(defcfun ("Pa_OpenDefaultStream" %open-default-stream) pa-error
  (pa-stream :pointer)
  (num-input-channels :int)
  (num-output-channels :int)
  (sample-format :unsigned-long)
  (sample-rate :double)
  (frames-per-buffer :unsigned-long)
  (stream-callback :pointer)
  (user-data (:pointer :void)))
(defun open-default-stream (num-input num-output sample-format sample-rate frames-per-buffer)
"
A simplified version of @fun{open-stream} that opens the default input and/or output devices.

@arg[num-input-channels]{The number of channels of sound that will be returned by @fun{read-stream}. It can range from 1 to the value of max-input-channels in the @class{device-info} class for the default input device. If 0 the stream is opened as an output-only stream.}
@arg[num-output-channels]{The number of channels of sound to be passed to @fun{write-stream}. It can range from 1 to the value of max-output-channels in the @class{device-info} class for the default output device. If 0 the stream is opened as an output-only stream.}
@arg[sample-format]{The sample format of both the input and output buffers passed to and from @fun{read-stream} and @fun{write-stream}. sample-format may be any of the formats described by the sample-format enumeration.}
@arg[sample-rate]{Same as @fun{open-stream} parameter of the same name.}
@arg[frames-per-buffer]{Same as @fun{open-stream} parameter of the same name.}

@result{As for @fun{open-stream}}
"
  (with-foreign-object (handle :pointer)
    (raise-if-error (%open-default-stream handle num-input num-output
                                          (foreign-bitfield-value 'sample-format (list sample-format)) 
                                          sample-rate frames-per-buffer
                                          (null-pointer) (null-pointer)))
    (make-instance 'pa-stream :handle (mem-ref handle :pointer)
                              :input-sample-format sample-format
                              :input-channels (if (= num-input 0) nil num-input)
                              :output-sample-format sample-format
                              :output-channels (if (= num-output 0) nil num-output)
                              :frames-per-buffer frames-per-buffer)))
(export 'open-default-stream)

;;(defctype stream-flags :unsigned-long)

(defcfun ("Pa_OpenStream" %open-stream) pa-error (pa-stream :pointer)
  (input-parameters p-stream-parameters)
  (output-parameters p-stream-parameters)
  (sample-rate :double)
  (frames-per-buffer :unsigned-long)
  (stream-flags stream-flags)
  (stream-callback :pointer)
  (user-data (:pointer :void)))

(defun open-stream (input-parameters output-parameters sample-rate frames-per-buffer stream-flags)
"
Opens a stream for either input, output or both.

@arg[input-parameters]{A structure that describes the input parameters used by the opened stream. See @class{stream-parameters} for a description of these parameters. input-parameters must be NIL for output-only streams.}
@arg[output-parameters]{A structure that describes the output parameters used by the opened stream. See @class{stream-parameters} for a description of these parameters. output-parameters must be NIL for input-only streams.}
@arg[sample-rate]{The desired sample-rate. For full-duplex streams it is the sample rate for both input and output}
@arg[frames-per-buffer]{Preferred block granularity for a blocking read/write stream.}
@arg[stream-flags]{List of flags which modify the behavior of the streaming process. Some flags may only be relevant to certain buffer formats.}

@begin{return}
Upon success pen-stream returns object of @class{pa-stream} class. The stream is inactive (stopped). If a call to open-stream fails, an error code is raised and the value of stream is NIL.
@end{return}
"
  (with-foreign-object (handle :pointer)
    (raise-if-error (%open-stream handle input-parameters output-parameters sample-rate frames-per-buffer
                                  stream-flags
                                  (null-pointer) (null-pointer)))
    (make-instance 'pa-stream :handle (mem-ref handle :pointer)
                              :input-sample-format
                              (when input-parameters (stream-parameters-sample-format input-parameters))
                              :input-channels
                              (when input-parameters (stream-parameters-channel-count input-parameters))
                              :output-sample-format
                              (when output-parameters (stream-parameters-sample-format output-parameters))
                              :output-channels
                              (when output-parameters (stream-parameters-channel-count output-parameters))
                              :frames-per-buffer frames-per-buffer)))
(export 'open-stream)

(defcfun ("Pa_CloseStream" %close-stream) pa-error (pa-stream p-pa-stream))
(defun close-stream (pa-stream)
  "Closes an audio stream. If the audio stream is active it discards any pending buffers as if @fun{abort-stream} had been called."
  (unwind-protect
       (raise-if-error (%close-stream pa-stream))
    (setf (pa-stream-handle pa-stream) (null-pointer))))
(export 'close-stream)

(defcfun ("Pa_IsStreamStopped" %is-stream-stopped) pa-error (pa-stream p-pa-stream))
(defun is-stream-stopped (pa-stream)
"
Determine whether the stream is stopped. A stream is considered to be stopped prior to a successful call to @fun{start-stream} and after a successful call to @fun{stop-stream} or @fun{abort-stream}.

@begin{return}
Returns one (1) when the stream is stopped, zero (0) when the stream is running or, raises an error if PortAudio is not initialized or an error is encountered.
@end{return}
"
  (raise-if-error (%is-stream-stopped pa-stream))) 
(export 'is-stream-stopped)

(defcfun ("Pa_GetStreamTime" %get-stream-time) pa-time (pa-stream p-pa-stream))
(defun get-stream-time (pa-stream)
  "Returns valid time values for the entire life of the stream, from when the stream is opened until it is closed. Starting and stopping the stream does not affect the passage of time returned by get-stream-time.

This time may be used for synchronizing other events to the audio stream, for example synchronizing audio to MIDI.

@result{The stream's current time in seconds, or 0 if an error occurred.}"
  (%get-stream-time pa-stream))
(export 'get-stream-time)

(defcfun ("Pa_GetHostApiCount" %get-host-api-count) host-api-index)
(defun get-host-api-count ()
  "Retrieve the number of available host APIs. Even if a host API is available it may have no devices available.
@begin{return}
A non-negative value indicating the number of available host APIs or, raises an error if PortAudio is not initialized or an error is encountered.
@end{return}"
  (raise-if-error (%get-host-api-count)))
(export 'get-host-api-count)

(defcfun ("Pa_IsStreamActive" %is-stream-active) :int (pa-stream p-pa-stream))
(defun is-stream-active (pa-stream)
"
Determine whether the stream is active. A stream is active after a successful call to @fun{start-stream}, until it becomes inactive either as a result of a call to @fun{stop-stream} or @fun{abort-stream}. In the latter case, the stream is considered inactive after the last buffer has finished playing.

@begin{return}
Returns one (1) when the stream is active (ie playing or recording audio), zero (0) when not playing or, raises an error if PortAudio is not initialized or an error is encountered.
@end{return}
"
  (raise-if-error (%is-stream-active pa-stream)))
(export 'is-stream-active)


(defcfun ("Pa_GetStreamWriteAvailable" %get-stream-write-available) :long
  (pa-stream p-pa-stream))
(defun get-stream-write-available (pa-stream)
  "Retrieve the number of frames that can be written to the stream without waiting.

@begin{return}
A non-negative value representing the maximum number of frames that can be written to the stream without blocking or busy waiting or, raises an error if PortAudio is not initialized or an error is encountered. 
@end{return}
"
  (raise-if-error (%get-stream-write-available pa-stream)))
(export 'get-stream-write-available)

(defcfun ("Pa_GetStreamReadAvailable" %get-stream-read-available) :long
  (pa-stream p-pa-stream))
(defun get-stream-read-available (pa-stream)
  "Retrieve the number of frames that can be read from the stream without waiting.

@begin{return}
Returns a non-negative value representing the maximum number of frames that can be read from the stream without blocking or busy waiting or, raises an error if PortAudio is not initialized or an error is encountered.
@end{return}
"
  (raise-if-error (%get-stream-read-available pa-stream)))
(export 'get-stream-read-available)

(defcfun ("Pa_ReadStream" %read-stream) pa-error (pa-stream p-pa-stream)
  (buffer (:pointer :void))
  (frames :unsigned-long))
(defun read-stream (pa-stream)
"
Read samples from an input stream. The function doesn't return until the entire buffer has been filled - this may involve waiting for the operating system to supply the data. Size of returned array equal to @code{(* frames-per-buffer channel-count)}.

@arg[pa-stream]{A object of stream previously created with @fun{open-stream}.}

@begin{return}
On success array of data will be returned, or :input-overflowed if input data was discarded by PortAudio after the previous call and before this call. 
@end{return}
"
  (let* ((sample-format (pa-stream-input-sample-format pa-stream))
         (frames (pa-stream-frames-per-buffer pa-stream))
         (channel-count (pa-stream-input-channels pa-stream))
         (array (make-array (* channel-count frames) :element-type (cffi-type-to-lisp sample-format))))
    (when (and sample-format
               channel-count)
      (with-pointer-to-array (array pointer sample-format (* channel-count frames) :copy-out)
         (%read-stream pa-stream pointer frames))
      array)))
(export 'read-stream)

(defun separate-array-to-channels (pa-stream array)
  "Separate flat array

@arg[pa-stream]{A object of stream previously created with @fun{open-stream}.}
@arg[array]{Flat array, that is received from @fun{read-stream}.}

@begin{return}
 (channelcount)-dimensional array of single-floats
@end{return}
"
  (let* ((sample-format (pa-stream-input-sample-format pa-stream))
         (frames (pa-stream-frames-per-buffer pa-stream))
         (channel-count (pa-stream-input-channels pa-stream))
         (separated (make-array (list channel-count frames) :element-type (cffi-type-to-lisp sample-format))))
    (dotimes (frame frames separated)
      (dotimes (channel channel-count separated)
        (setf (aref separated channel frame) (aref array (+ (* frame channel-count) channel)))))))
(export 'separate-array-to-channels)
(defun merge-channels-into-array (pa-stream channels)
  "Merge subarrays of (channelcount)-dimensional array to flat array.

@arg[pa-stream]{A object of stream previously created with @fun{open-stream}.}
@arg[channels]{Vector of vectors of floats, that contains data for all sound channels.}

@begin{return}
Vector of data, that can be used with @fun{write-stream}.
@end{return}
"
  (let* ((sample-format (pa-stream-input-sample-format pa-stream))
         (frames (pa-stream-frames-per-buffer pa-stream))
         (channel-count (pa-stream-input-channels pa-stream))
         (merged (make-array (* frames channel-count) :element-type (cffi-type-to-lisp sample-format))))
    (dotimes (frame frames merged)
      (dotimes (channel channel-count merged)
        (setf (aref merged (+ (* frame channel-count) channel)) (aref channels channel frame))))))
(export 'merge-channels-into-array)

(defun read-stream-into-array (pa-stream array)
  "Read samples from an input stream. The function doesn't return until the entire buffer has been filled - this may involve waiting for the operating system to supply the data. 

@arg[pa-stream]{A object of stream previously created with @fun{open-stream}.}
@arg[array]{Simple array with has element-type equal to sample-format from @fun{open-stream}. Size of array equal to @code{(* frames-per-buffer channel-count)}.}

@begin{return}
On success NIL will be returned, or :input-overflowed if input data was discarded by PortAudio after the previous call and before this call. 
@end{return}"
  (let* ((sample-format (pa-stream-input-sample-format pa-stream))
         (frames (pa-stream-frames-per-buffer pa-stream))
         (channel-count (pa-stream-input-channels pa-stream)))
    (when (and sample-format
               channel-count)
      (with-pointer-to-array (array pointer sample-format (* channel-count frames) :copy-out)
        (%read-stream pa-stream pointer frames)))))
(export 'read-stream-into-array)

(defcfun ("Pa_WriteStream" %write-stream) pa-error (pa-stream p-pa-stream)
  (buffer :pointer)
  (frames :unsigned-long))
(defun write-stream (pa-stream buffer)
"Write samples to an output stream. This function doesn't return until the entire buffer has been consumed - this may involve waiting for the operating system to consume the data. Size of buffer should be equal to @code{(* frames-per-buffer channel-count)}.

@arg[pa-stream]{A object of stream previously created with @fun{open-stream}.}
@arg[buffer]{A array of sample frames. The buffer contains samples in the format specified by the @code{(stream-parameters-sample-format output-parameters)} field used to open the stream, and the number of channels specified by @code{(stream-parameters-num-channels output-parameters)}.}

@begin{return}
On success NIL will be returned, or :output-underflowed if additional output data was inserted after the previous call and before this call. 
@end{return}
"
  (let* ((sample-format (pa-stream-output-sample-format pa-stream))
         (frames (pa-stream-frames-per-buffer pa-stream))
         (channel-count (pa-stream-output-channels pa-stream)))
    (when (and sample-format
               channel-count)
      (with-pointer-to-array (buffer pointer sample-format (* channel-count frames) :copy-in)
        (%write-stream pa-stream pointer frames)))))

(export 'write-stream)

(defcfun ("Pa_StartStream" %start-stream) pa-error (pa-stream p-pa-stream))
(defun start-stream (pa-stream)
  "Commences audio processing."
  (raise-if-error (%start-stream pa-stream)))
(export 'start-stream)

(defcfun ("Pa_AbortStream" %abort-stream) pa-error (pa-stream p-pa-stream))
(defun abort-stream (pa-stream)
  "Terminates audio processing immediately without waiting for pending buffers to complete."
  (raise-if-error (%abort-stream pa-stream)))
(export 'abort-stream)

(defcfun ("Pa_StopStream" %stop-stream) pa-error (pa-stream p-pa-stream))
(defun stop-stream (pa-stream)
  "Terminates audio processing. It waits until all pending audio buffers have been played before it returns."
  (raise-if-error (%stop-stream pa-stream))) 

(defcstruct stream-info
  (struct-version :int)
  (input-latency pa-time)
  (output-latency pa-time)
  (sample-rate :double))

(defclass stream-info nil
  ((struct-version :reader stream-info-struct-version :documentation "Struct version")
   (input-latency :reader stream-info-input-latency :documentation "The input latency of the stream in seconds. This value provides the most accurate estimate of input latency available to the implementation. It may differ significantly from the suggestedLatency value passed to open-stream. The value of this field will be zero (0.) for output-only streams.")
   (output-latency :reader stream-info-output-latency :documentation "The output latency of the stream in seconds. This value provides the most accurate estimate of output latency available to the implementation. It may differ significantly from the suggestedLatency value passed to open-stream. The value of this field will be zero (0.) for input-only streams.")
   (sample-rate :reader stream-info-sample-rate :documentation "The sample rate of the stream in Hertz (samples per second). In cases where the hardware sample rate is inaccurate and PortAudio is aware of it, the value of this field may be different from the sample-rate parameter passed to open-stream. If information about the actual hardware sample rate is not available, this field will have the same value as the sample-rate parameter passed to open-stream."))
  (:documentation "A structure containing unchanging information about an open stream."))
(defmethod initialize-instance :after
    ((inst stream-info) &key pointer)
  (with-foreign-slots ((struct-version input-latency output-latency
                                       sample-rate)
                       pointer stream-info)
    (setf (slot-value inst 'struct-version) struct-version)
    (setf (slot-value inst 'input-latency) input-latency)
    (setf (slot-value inst 'output-latency) output-latency)
    (setf (slot-value inst 'sample-rate) sample-rate)))
(export 'stream-info)
(export 'stream-info-input-latency)
(export 'stream-info-output-latency)
(export 'stream-info-sample-rate)

(defgeneric stream-info-input-latency  (instance) (:documentation "The input latency of the stream in seconds. This value provides the most accurate estimate of input latency available to the implementation. It may differ significantly from the suggestedLatency value passed to open-stream. The value of this field will be zero (0.) for output-only streams.")) 
(defgeneric stream-info-output-latency (instance) (:documentation "The output latency of the stream in seconds. This value provides the most accurate estimate of output latency available to the implementation. It may differ significantly from the suggestedLatency value passed to open-stream. The value of this field will be zero (0.) for input-only streams.")) 
(defgeneric stream-info-sample-rate    (instance) (:documentation "The sample rate of the stream in Hertz (samples per second). In cases where the hardware sample rate is inaccurate and PortAudio is aware of it, the value of this field may be different from the sample-rate parameter passed to open-stream. If information about the actual hardware sample rate is not available, this field will have the same value as the sample-rate parameter passed to open-stream."))

(defctype p-stream-info :pointer "Pointer to stream-info")
(define-foreign-type p-stream-info ()
  ()
  (:actual-type :pointer)
  (:simple-parser p-stream-info))
(defmethod translate-from-foreign (value (type p-stream-info))
  (unless (null-pointer-p value)
    (make-instance 'stream-info :pointer value)))

(defcfun ("Pa_GetStreamInfo" %get-stream-info) p-stream-info (pa-stream p-pa-stream))
(defun get-stream-info (pa-stream)
  "Retrieve a object of class @class{stream-info} containing information about the specified stream.

@begin{return}
A object of @class{stream-info} structure. If the stream parameter invalid, or an error is encountered, the function returns NIL.
@end{return}

@arg[pa-stream]{A object of stream previously created with @fun{open-stream}.}
"
  (%get-stream-info pa-stream))
(export 'get-stream-info)

(defcfun ("Pa_GetSampleSize" %get-sample-size) :int (format sample-format))
(defun get-sample-size (format)
  "Retrieve the size of a given sample format in bytes.
@result{The size in bytes of a single sample in the specified format, or paSampleFormatNotSupported if the format is not supported.}"
  (raise-if-error (%get-sample-size (foreign-bitfield-value 'sample-format (list format)))))
(export 'get-sample-size)

(defcfun ("Pa_HostApiDeviceIndexToDeviceIndex" %host-api-device-index-to-device-index) device-index
  (host-api host-api-index)
  (host-api-device-index :int))
(defun host-api-device-index-to-device-index (host-api host-api-device-index)
  "Convert a host-API-specific device index to standard PortAudio device index. This function may be used in conjunction with the deviceCount field of PaHostApiInfo to enumerate all devices for the specified host API.

@arg[host-api]{A valid host API index ranging from 0 to @code{(- (@fun{get-host-api-count}) 1)}}
@arg[host-api-device-index]{A valid per-host device index in the range 0 to @code{(- (@fun{host-api-info-device-count} (@fun{get-host-api-info} host-api)) 1)}}

@begin{return}
A non-negative index ranging from 0 to @code{(- (@fun{get-device-count}) 1)} or, raises an error if PortAudio is not initialized or an error is encountered.
@end{return}

A invalid-host-api error indicates that the host API index specified by the hostApi parameter is out of range.

A invalid-device error indicates that the host-api-device-index parameter is out of range.
"
  (raise-if-error (%host-api-device-index-to-device-index host-api host-api-device-index)))
(export 'host-api-device-index-to-device-index)

(defcfun ("Pa_Sleep" %pa-sleep) :void (msec :long))
(defun pa-sleep (msec)
"
Put the caller to sleep for at least 'msec' milliseconds. This function is provided only as a convenience for authors of portable code (such as the tests and examples in the PortAudio distribution.)

The function may sleep longer than requested so don't rely on this for accurate musical timing.
"
  (%pa-sleep msec))
(export 'pa-sleep)

(defmacro with-audio (&body body)
  "Execute body in PortAudio initialize/terminate environment."
  `(progn
     (initialize)
     (unwind-protect
          (progn
            ,@body)
       (progn
         (terminate)))))
(export 'with-audio)

;; Generated by me, based on "Joost Diepenmaat <joost@zeekat.nl>" version
(defmacro with-default-audio-stream ((var num-input num-output &key (sample-format :float) (sample-rate 44100d0) (frames-per-buffer 1024)) &body body)
  "Execute body with opened and started stream VAR and shut down
   the stream after it is done. It is required use these macro in with-audio or initialize/terminate environment."
  `(let ((,var nil))
     (unwind-protect
          (progn
            (setf ,var (open-default-stream ,num-input ,num-output ,sample-format ,sample-rate ,frames-per-buffer))
            (start-stream ,var)
            ,@body)
       (progn
         (when ,var
           (stop-stream ,var)
           (close-stream ,var))))))
(export 'with-default-audio-stream)

(defmacro with-audio-stream ((var input-parameters output-parameters &key (sample-rate 44100d0) (frames-per-buffer 1024) (stream-flags (list :no-flag))) &body body)
  "Execute body with opened and started stream VAR and shut down
   the stream after it is done. It is required use these macro in with-audio or initialize/terminate environment."
  `(let ((,var nil))
     (unwind-protect
          (progn
            (setf ,var (open-stream ,input-parameters ,output-parameters ,sample-rate ,frames-per-buffer ',stream-flags))
            (start-stream ,var)
            ,@body)
       (progn
         (when ,var
           (stop-stream ,var)
           (close-stream ,var))))))
(export 'with-audio-stream)

(defun print-supported-standard-sample-rates (input-params output-params)
  (mapcar
   (lambda (rate)
     (ignore-errors
      (unless (is-format-supported input-params output-params rate)
        (format t "~8,2F, " rate))))
   '(8000d0 9600d0 11025d0 12000d0 16000d0 22050d0 24000d0 32000d0
     44100d0 48000d0 88200d0 96000d0 192000d0))
  (format t "~%"))

(defun print-devices ()
  "List available sound devices, including device information."
  (with-audio
    (format t "PortAudio version number = ~D~%PortAudio version text = ~A~%"
            (get-version) (get-version-text))
    (let ((num-devices (get-device-count))
          (input-parameters (make-stream-parameters))
          (output-parameters (make-stream-parameters)))
      (format t "Number of devices = ~D~%" num-devices)
      (dotimes (i num-devices)
        (let ((device-info (get-device-info i))
              (default-displayed nil))
          (format t "---------------------- device ~D~%" i)
          (if (= i (get-default-input-device))
              (progn
                (format t "[ Default Input")
                (setf default-displayed t))
              (when (= i (host-api-info-default-input-device (get-host-api-info (device-info-host-api device-info))))
                (format t "[ Default ~A Input" (get-host-api-info (device-info-host-api device-info)))
                (setf default-displayed t)))
          
          (if (= i (get-default-output-device))
              (progn
                (format t "~:[[~;,~]" default-displayed)
                (format t " Default Output")
                (setf default-displayed t))
              (when (= i (host-api-info-default-output-device (get-host-api-info (device-info-host-api device-info))))
                (format t "~:[[~;,~]" default-displayed)
                (format t "[ Default ~A Output" (get-host-api-info (device-info-host-api device-info)))
                (setf default-displayed t)))
          (when default-displayed
            (format t " ]~%"))
          (format t "Name                        = ~A~%" (device-info-name device-info))
          (format t "Host API                    = ~A~%" (host-api-info-name (get-host-api-info (device-info-host-api device-info))))
          (format t "Max inputs = ~D" (device-info-max-input-channels device-info))
          (format t ", Max outputs = ~D~%" (device-info-max-output-channels device-info))
          (format t "Default low input latency   = ~8,4F~%" (device-info-default-low-input-latency device-info))
          (format t "Default low output latency  = ~8,4F~%" (device-info-default-low-output-latency device-info))
          (format t "Default high input latency  = ~8,4F~%" (device-info-default-high-input-latency device-info))
          (format t "Default high output latency = ~8,4F~%" (device-info-default-high-output-latency device-info))
          (format t "Default sample rate         = ~8,4F~%" (device-info-default-sample-rate device-info))
          
          (setf
           (stream-parameters-device input-parameters) i
           (stream-parameters-channel-count input-parameters) (device-info-max-input-channels device-info)
           (stream-parameters-sample-format input-parameters) :float
           (stream-parameters-suggested-latency input-parameters) 0d0

           (stream-parameters-device output-parameters) i
           (stream-parameters-channel-count output-parameters) (device-info-max-output-channels device-info)
           (stream-parameters-sample-format output-parameters) :float
           (stream-parameters-suggested-latency output-parameters) 0d0)

          (when (< 0 (stream-parameters-channel-count input-parameters))
            (format t "Supported standard sample rates~% for half-duplex float 32 bit ~D channel input = ~%"
                    (stream-parameters-channel-count input-parameters))
            (print-supported-standard-sample-rates input-parameters nil))

          (when (< 0 (stream-parameters-channel-count output-parameters))
            (format t "Supported standard sample rates~% for half-duplex float 32 bit ~D channel output = ~%"
                    (stream-parameters-channel-count output-parameters))
            (print-supported-standard-sample-rates nil output-parameters))

          (when (and (< 0 (stream-parameters-channel-count input-parameters)) (< 0 (stream-parameters-channel-count output-parameters)))
            (format t "Supported standard sample rates~% for full-duplex float 32 bit ~D channel input, ~D channel output = ~%"
                    (stream-parameters-channel-count input-parameters)
                    (stream-parameters-channel-count output-parameters))
            (print-supported-standard-sample-rates input-parameters output-parameters))))
      (format t "--------------------~%"))))
(export 'print-devices)
